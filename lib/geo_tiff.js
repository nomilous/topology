// Generated by CoffeeScript 1.4.0
var GeoTiff, fs;

fs = require('fs');

GeoTiff = (function() {

  function GeoTiff(filename) {
    this.filename = filename;
  }

  GeoTiff.prototype.loadFile = function(callback) {
    var _this = this;
    this.callback = callback;
    return fs.readFile(this.filename, function(err, buffer) {
      var byteOrder, offset;
      _this.buffer = buffer;
      if (err) {
        callback(err);
        return;
      }
      byteOrder = _this.buffer.toString('utf8', 0, 2);
      if (byteOrder === 'II') {
        _this.shortFn = 'readUInt16LE';
        _this.longFn = 'readUInt32LE';
        _this.doubleFn = 'readDoubleLE';
      } else if (byteOrder === 'MM') {
        _this.shortFn = 'readUInt16BE';
        _this.longFn = 'readUInt32BE';
        _this.doubleFn = 'readDoubleBE';
      } else {
        _this.callback('NOT TIFF');
        return;
      }
      if (_this.buffer[_this.shortFn](2) !== 42) {
        _this.callback('NOT TIFF');
        return;
      }
      offset = _this.buffer[_this.longFn](4);
      return _this.decodeRaster(_this.loadIFD(offset));
    });
  };

  GeoTiff.prototype.loadIFD = function(offset) {
    var IFD, IFDoffset, count, record, seq, tag, type, valuesCount, valuesOffset, _i, _ref;
    IFD = {};
    count = this.buffer[this.shortFn](offset);
    offset += 2;
    for (seq = _i = 0, _ref = count - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; seq = 0 <= _ref ? ++_i : --_i) {
      IFDoffset = offset + seq * 12;
      tag = this.buffer[this.shortFn](IFDoffset);
      IFDoffset += 2;
      type = this.buffer[this.shortFn](IFDoffset);
      IFDoffset += 2;
      valuesCount = this.buffer[this.longFn](IFDoffset);
      IFDoffset += 4;
      valuesOffset = this.buffer[this.longFn](IFDoffset);
      record = {
        tag: tag,
        type: type,
        valuesCount: valuesCount,
        valuesOffset: valuesOffset
      };
      switch (tag) {
        case 256:
          IFD.width = this.getRecord(record);
          break;
        case 257:
          IFD.length = this.getRecord(record);
          break;
        case 258:
          IFD.bitsPerSample = this.getRecord(record);
          break;
        case 259:
          IFD.compressed = this.getRecord(record);
          if (IFD.compressed !== 1) {
            this.callback('COMPRESSION NOT SUPPORTED');
            return;
          }
          break;
        case 262:
          IFD.photometric = this.getRecord(record);
          break;
        case 269:
          IFD.name = this.getRecord(record);
          break;
        case 270:
          IFD.description = this.getRecord(record);
          break;
        case 273:
          IFD.stripOffsets = this.getRecord(record);
          break;
        case 277:
          IFD.samplesPerPixel = this.getRecord(record);
          break;
        case 278:
          IFD.rowsPerStrip = this.getRecord(record);
          break;
        case 279:
          IFD.stripByteCounts = this.getRecord(record);
          break;
        case 282:
          IFD.xResolution = this.getRecord(record);
          break;
        case 283:
          IFD.yResolution = this.getRecord(record);
          break;
        case 284:
          IFD.planarConfig = this.getRecord(record);
          break;
        case 296:
          IFD.resolutionUnit = this.getRecord(record);
          break;
        case 305:
          IFD.software = this.getRecord(record);
          break;
        case 306:
          IFD.timestamp = this.getRecord(record);
          break;
        case 339:
          IFD.sampleFormat = this.getRecord(record);
          break;
        case 33550:
          IFD.modelPixelScale = this.getRecord(record);
          break;
        case 33922:
          IFD.modelGeoReference = this.getRecord(record);
          break;
        case 34735:
          continue;
        case 34736:
          continue;
        case 34737:
          continue;
      }
    }
    return IFD;
  };

  GeoTiff.prototype.getRecord = function(record) {
    var denominator, end, numerator, seq, start, values, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
    switch (record.type) {
      case 2:
        start = record.valuesOffset;
        end = record.valuesOffset + record.valuesCount - 1;
        return this.buffer.toString('utf8', start, end);
      case 3:
        if (record.valuesCount <= 1) {
          return record.valuesOffset;
        }
        values = [];
        for (seq = _i = 0, _ref = record.valuesCount - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; seq = 0 <= _ref ? ++_i : --_i) {
          values.push(this.buffer[this.shortFn](record.valuesOffset + seq * 2));
        }
        return values;
      case 4:
        if (record.valuesCount <= 1) {
          return record.valuesOffset;
        }
        values = [];
        for (seq = _j = 0, _ref1 = record.valuesCount - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; seq = 0 <= _ref1 ? ++_j : --_j) {
          values.push(this.buffer[this.longFn](record.valuesOffset + seq * 4));
        }
        if (values.length > 1) {
          return values;
        }
        return values[0];
      case 5:
        values = [];
        for (seq = _k = 0, _ref2 = record.valuesCount - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; seq = 0 <= _ref2 ? ++_k : --_k) {
          numerator = this.buffer[this.longFn](record.valuesOffset + seq * 4);
          denominator = this.buffer[this.longFn](record.valuesOffset + seq * 4 + 4);
          values.push(numerator / denominator);
        }
        if (values.length > 1) {
          return values;
        }
        return values[0];
      case 12:
        values = [];
        for (seq = _l = 0, _ref3 = record.valuesCount - 1; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; seq = 0 <= _ref3 ? ++_l : --_l) {
          values.push(this.buffer[this.doubleFn](record.valuesOffset + seq * 8));
        }
        if (values.length > 1) {
          return values;
        }
        return values[0];
    }
  };

  GeoTiff.prototype.decodeRaster = function(IFD) {
    var bytes, colSeq, end, i, j, offset, row, rowSeq, strip, stripSeq, tile, value, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _ref, _ref1, _ref2, _results, _results1, _results2;
    tile = {
      raster: [],
      pixelScale: IFD.modelPixelScale,
      geoReference: IFD.modelGeoReference
    };
    stripSeq = (function() {
      _results = [];
      for (var _i = 0, _ref = IFD.stripOffsets.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    rowSeq = (function() {
      _results1 = [];
      for (var _j = 0, _ref1 = IFD.rowsPerStrip - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; 0 <= _ref1 ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this);
    colSeq = (function() {
      _results2 = [];
      for (var _k = 0, _ref2 = IFD.width - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; 0 <= _ref2 ? _k++ : _k--){ _results2.push(_k); }
      return _results2;
    }).apply(this);
    bytes = IFD.bitsPerSample / 8;
    try {
      for (_l = 0, _len = stripSeq.length; _l < _len; _l++) {
        strip = stripSeq[_l];
        offset = IFD.stripOffsets[strip];
        end = IFD.stripByteCounts[strip] + offset;
        for (_m = 0, _len1 = rowSeq.length; _m < _len1; _m++) {
          i = rowSeq[_m];
          if (offset >= end) {
            continue;
          }
          row = [];
          for (_n = 0, _len2 = colSeq.length; _n < _len2; _n++) {
            j = colSeq[_n];
            if (offset >= end) {
              continue;
            }
            value = this.buffer[this.shortFn](offset);
            offset += bytes;
            row.push(value);
          }
          tile.raster.push(row);
        }
      }
    } catch (error) {
      this.callback(error);
      return;
    }
    return this.callback(null, tile);
  };

  return GeoTiff;

})();

module.exports = GeoTiff;
