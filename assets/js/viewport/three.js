// Generated by CoffeeScript 1.6.2
var ActorService, AnimateService, FirstPersonService, SceneService, ng;

ng = angular.module('viewport', []);

SceneService = function($log) {
  var scene;

  return scene = {
    scene: new THREE.Scene(),
    init: function(elem, attrs) {
      var type;

      type = attrs.rendererType || 'CanvasRenderer';
      scene.renderer = new THREE[type]();
      scene.renderer.setSize(elem[0].clientWidth, elem[0].clientHeight);
      return elem[0].appendChild(scene.renderer.domElement);
    },
    add: function(object) {
      return scene.scene.add(object);
    }
  };
};

ActorService = function($log, sceneService) {
  var actors, service;

  actors = {};
  return service = {
    init: function(elem, attrs) {},
    add: function(actor) {
      sceneService.add(actor.object);
      return actors[actor._id] = actor;
    },
    get: function(id) {
      return actors[id];
    }
  };
};

FirstPersonService = function($log, sceneService) {
  var firstPerson;

  return firstPerson = {
    init: function(elem, attrs) {
      var aspect, far, fov, near, type;

      type = attrs.cameraType || 'PerspectiveCamera';
      fov = parseInt(attrs.fieldOfView || 75);
      aspect = elem[0].clientWidth / elem[0].clientHeight;
      near = parseInt(attrs.nearClip || 1);
      far = parseInt(attrs.farClip || 100000);
      firstPerson.camera = new THREE[type](fov, aspect, near, far);
      firstPerson.controls = new THREE.FirstPersonControls(firstPerson.camera);
      firstPerson.controls.movementSpeed = 100;
      firstPerson.controls.lookSpeed = 0.125;
      firstPerson.controls.lookVertical = true;
      firstPerson.controls.constrainVertical = false;
      firstPerson.controls.verticalMin = 1.1;
      firstPerson.controls.verticalMax = 2.2;
      return firstPerson.clock = new THREE.Clock();
    }
  };
};

AnimateService = function($log, sceneService, firstPersonService) {
  var animate, events;

  events = {
    'before:animate': [],
    'after:animate': []
  };
  return animate = {
    init: function(elem, attrs) {},
    on: function(event, callback) {
      var error;

      try {
        return events[event].push(callback);
      } catch (_error) {
        error = _error;
        return $log.error('AnimateService.on("%s"): NO SUCH EVENT', event);
      }
    },
    loop: function() {
      var callback, _i, _j, _len, _len1, _ref, _ref1, _results;

      _ref = events['before:animate'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        callback();
      }
      firstPersonService.controls.update(firstPersonService.clock.getDelta());
      requestAnimationFrame(animate.loop);
      sceneService.renderer.render(sceneService.scene, firstPersonService.camera);
      _ref1 = events['after:animate'];
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        callback = _ref1[_j];
        _results.push(callback());
      }
      return _results;
    }
  };
};

ng.factory('sceneService', SceneService);

ng.factory('actorService', ActorService);

ng.factory('firstPersonService', FirstPersonService);

ng.factory('animateService', AnimateService);

ng.directive('threeFirstPerson', function($log, firstPersonService) {
  return {
    restrict: 'E',
    compile: function(elem, attrs) {
      firstPersonService.camera.position.x = parseInt(attrs.modelPositionX || 0);
      firstPersonService.camera.position.y = parseInt(attrs.modelPositionY || 0);
      return firstPersonService.camera.position.z = parseInt(attrs.modelPositionZ || 0);
    }
  };
});

ng.directive('threeViewport', function($log, sceneService, actorService, firstPersonService, animateService) {
  return {
    restrict: 'E',
    compile: function(elem, attrs) {
      sceneService.init(elem, attrs);
      actorService.init(elem, attrs);
      firstPersonService.init(elem, attrs);
      animateService.init(elem, attrs);
      return animateService.loop();
    }
  };
});
